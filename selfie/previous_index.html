<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Selfie Camera</title>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .camera-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 800px;
            width: 100%;
        }

        .video-container {
            position: relative;
            margin-bottom: 30px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        #video {
            width: 100%;
            height: auto;
            transform: scaleX(-1);
            display: block;
        }

        .overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }

        .face-indicator {
            position: absolute;
            border: 3px solid #4ecdc4;
            border-radius: 10px;
            display: none;
            pointer-events: none;
        }

        .smile-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(46, 204, 113, 0.9);
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            display: none;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #4ecdc4, #45b7aa);
            color: white;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .format-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .format-selector label {
            font-weight: bold;
        }

        .format-selector select {
            padding: 8px 15px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-weight: bold;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .toggle {
            position: relative;
            width: 60px;
            height: 30px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle.active {
            background: #4ecdc4;
        }

        .toggle::after {
            content: '';
            position: absolute;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .toggle.active::after {
            transform: translateX(30px);
        }

        .detection-settings {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .sensitivity-slider {
            margin: 10px 0;
        }

        .sensitivity-slider input {
            width: 200px;
            margin: 0 10px;
        }

        .preview-container {
            margin-top: 30px;
            text-align: center;
        }

        .preview-images {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }

        .preview-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 10px;
            max-width: 200px;
            position: relative;
        }

        .preview-item img {
            width: 100%;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .download-btn, .delete-btn, .upload-btn {
            background: linear-gradient(45deg, #10ac84, #00d2d3);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            margin: 5px;
        }

        .delete-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }
        .upload-btn {
            background: linear-gradient(45deg, #4285F4, #34A853);
        }

/* Add or replace in your CSS */
.status {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px; /* space between spinner and text */
  font-weight: bold;
}

.loading-text {
  font-size: 1rem;
  color: inherit;
}


        .status.success {
            background: rgba(46, 204, 113, 0.3);
        }

        .status.error {
            background: rgba(231, 76, 60, 0.3);
        }

        .status.loading {
            background: rgba(52, 152, 219, 0.3);
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status-with-loader {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .debug-info {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 12px;
            text-align: left;
            display: none;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .camera-container {
                padding: 20px;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            .btn {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üì∏ Smart Selfie Camera</h1>
        <p>Take Perfect Selfies with Manual or AI-Powered Smile Detection & Gestures!</p>
    </div>

    <div class="camera-container">
        <div class="video-container">
            <video id="video" autoplay muted></video>
            <div class="overlay" id="status-overlay">Camera Loading...</div>
            <div class="face-indicator" id="face-indicator"></div>
            <div class="smile-indicator" id="smile-indicator">üòä Smile Detected!</div>
            <div class="gesture-indicator" id="gesture-indicator" style="position: absolute; top: 15px; left: 50%; transform: translateX(-50%); background: rgba(255, 165, 0, 0.9); padding: 8px 12px; border-radius: 15px; font-size: 12px; font-weight: bold; display: none;">‚úåÔ∏è Gesture Detected!</div>
        </div>

        <div class="format-selector">
            <label for="format">Photo Format:</label>
            <select id="format">
                <option value="image/jpeg">JPG (Recommended)</option>
                <option value="image/png">PNG (High Quality)</option>
                <option value="image/webp">WebP (Compressed)</option>
            </select>
        </div>

        <div class="toggle-container">
            <span>AI Detection (Smile/Gesture):</span>
            <div class="toggle" id="ai-toggle"></div>
            <span id="ai-status">OFF</span>
        </div>

        <div class="detection-settings" id="detection-settings" style="display: none;">
            <p><strong>Detection Settings</strong></p>
            <div class="sensitivity-slider">
                <label>Sensitivity:</label>
                <input type="range" id="sensitivity" min="1" max="10" value="6">
                <span id="sensitivity-value">6</span>
            </div>
            <p style="font-size: 12px; opacity: 0.8;">Higher sensitivity = easier to trigger</p>
        </div>

        <div class="controls">
            <button class="btn btn-primary" id="start-camera">üéπ Start Camera</button>
            <button class="btn btn-secondary" id="capture" disabled>üì∏ Take Photo</button>
            <button class="btn btn-primary" id="stop-camera" disabled>‚èπÔ∏è Stop Camera</button>
        </div>

        <div id="status-message" class="status" style="display: none;"></div>

        <div class="preview-container">
            <h3>üì∑ Captured Photos:</h3>
            <div class="preview-images" id="preview-images"></div>
        </div>

        <div class="debug-info" id="debug-info">
            <p><strong>Detection Debug Info:</strong></p>
            <p>Face Detected: <span id="face-status">No</span></p>
            <p>Smile Score: <span id="smile-score">0</span></p>
            <p>Mouth Opening: <span id="mouth-opening">0</span></p>
            <p>Gesture Score: <span id="gesture-score">0</span></p>
        </div>
    </div>

    <canvas id="canvas" style="display: none;"></canvas>
    <canvas id="analysis-canvas" style="display: none;"></canvas>

    <script>
        // Global variables
        let smartCameraInstance;
        let gapiReady = false;

        // Google API callback function - must be global
        function initGoogleAPI() {
            gapiReady = true;
            if (smartCameraInstance) {
                smartCameraInstance.initGoogleAuth();
            }
        }

        class SmartSelfieCamera {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.analysisCanvas = document.getElementById('analysis-canvas');
                this.analysisCtx = this.analysisCanvas.getContext('2d');
                this.stream = null;
                this.isAIDetectionActive = false;
                this.lastAutoCaptureTime = 0;
                this.detectionInterval = null;
                this.photoCount = 0;
                this.sensitivity = 6;
                this.detectionHistory = [];
                this.frameCount = 0;
                this.lastFaceData = null;
                this.lastGestureData = null;
                
                // Google Photos API related
                this.googleAuth = null;
                this.googleClientId = '232902087900-1enl9luvmhihitttjg0ji3ceq5op091t.apps.googleusercontent.com';
                this.googleApiKey = 'AIzaSyBOxLJdBSbbfnZb9CidWRNvUtHUIMpSOW0';
                this.googleScopes = 'https://www.googleapis.com/auth/photoslibrary.appendonly';
                this.capturedBlobs = {};

                this.initializeElements();
                this.bindEvents();
                this.setupCanvas();
                
                // Initialize Google Auth if gapi is already loaded
                if (gapiReady) {
                    this.initGoogleAuth();
                }
            }

            initializeElements() {
                this.startBtn = document.getElementById('start-camera');
                this.captureBtn = document.getElementById('capture');
                this.stopBtn = document.getElementById('stop-camera');
                this.formatSelect = document.getElementById('format');
                this.aiToggle = document.getElementById('ai-toggle');
                this.aiStatus = document.getElementById('ai-status');
                this.statusOverlay = document.getElementById('status-overlay');
                this.statusMessage = document.getElementById('status-message');
                this.previewContainer = document.getElementById('preview-images');
                this.detectionSettings = document.getElementById('detection-settings');
                this.sensitivitySlider = document.getElementById('sensitivity');
                this.sensitivityValue = document.getElementById('sensitivity-value');
                this.faceIndicator = document.getElementById('face-indicator');
                this.smileIndicator = document.getElementById('smile-indicator');
                this.gestureIndicator = document.getElementById('gesture-indicator');
                this.debugInfo = document.getElementById('debug-info');
                this.debugSmileScore = document.getElementById('smile-score');
                this.debugMouthOpening = document.getElementById('mouth-opening');
                this.debugGestureScore = document.getElementById('gesture-score');
            }

            bindEvents() {
                this.startBtn.addEventListener('click', () => this.startCamera());
                this.captureBtn.addEventListener('click', () => this.capturePhoto());
                this.stopBtn.addEventListener('click', () => this.stopCamera());
                this.aiToggle.addEventListener('click', () => this.toggleAIDetection());
                this.sensitivitySlider.addEventListener('input', (e) => {
                    this.sensitivity = parseInt(e.target.value);
                    this.sensitivityValue.textContent = this.sensitivity;
                });
            }

            setupCanvas() {
                this.canvas.width = 640;
                this.canvas.height = 480;
                this.analysisCanvas.width = 320;
                this.analysisCanvas.height = 240;
            }

            // Google Photos Integration - Updated for new GIS library
            initGoogleAuth() {
                if (typeof gapi === 'undefined' || !gapi.client) {
                    console.log('Google API not ready yet, will retry...');
                    setTimeout(() => this.initGoogleAuth(), 1000);
                    return;
                }

                // Initialize gapi client without auth2
                gapi.client.init({
                    apiKey: this.googleApiKey,
                    discoveryDocs: ["https://photoslibrary.googleapis.com/$discovery/rest?version=v1"]
                }).then(() => {
                    console.log('Google API client initialized successfully');
                    
                    // Initialize Google Identity Services (new auth method)
                    if (typeof google !== 'undefined' && google.accounts) {
                        google.accounts.id.initialize({
                            client_id: this.googleClientId,
                            callback: this.handleGoogleSignIn.bind(this)
                        });
                        
                        // Initialize OAuth for Photos API
                        this.tokenClient = google.accounts.oauth2.initTokenClient({
                            client_id: this.googleClientId,
                            scope: this.googleScopes,
                            callback: (response) => {
                                if (response.access_token) {
                                    this.accessToken = response.access_token;
                                    console.log('OAuth token received');
                                }
                            }
                        });
                    }
                }).catch((error) => {
                    console.error('Error initializing Google API client:', error);
                });
            }

            handleGoogleSignIn(response) {
                console.log('Google Sign-In response:', response);
                // Handle sign-in response if needed
            }

            async signInToGoogle() {
                if (!this.tokenClient) {
                    this.showStatus('Google API not ready. Please wait and try again.', 'error');
                    return false;
                }
                
                try {
                    // Request access token
                    return new Promise((resolve) => {
                        this.tokenClient.callback = (response) => {
                            if (response.access_token) {
                                this.accessToken = response.access_token;
                                console.log('Successfully obtained access token');
                                resolve(true);
                            } else {
                                console.error('Failed to get access token:', response);
                                this.showStatus('Failed to get access token', 'error');
                                resolve(false);
                            }
                        };
                        this.tokenClient.requestAccessToken();
                    });
                } catch (error) {
                    console.error('Google sign-in error:', error);
                    this.showStatus('Google sign-in failed. Please try again.', 'error');
                    return false;
                }
            }

            async uploadToGooglePhotos(blob, filename) {
                if (!await this.signInToGoogle()) {
                    return;
                }

                this.showStatus('Uploading to Google Photos...', 'loading');
                try {
                    // Step 1: Upload the photo bytes
                    const uploadResponse = await fetch('https://photoslibrary.googleapis.com/v1/uploads', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/octet-stream',
                            'X-Goog-Upload-Content-Type': blob.type,
                            'X-Goog-Upload-Protocol': 'raw',
                            'Authorization': `Bearer ${this.accessToken}`
                        },
                        body: blob
                    });

                    if (!uploadResponse.ok) {
                        const errorText = await uploadResponse.text();
                        throw new Error(`Upload failed: ${uploadResponse.status} - ${errorText}`);
                    }
                    const uploadToken = await uploadResponse.text();

                    // Step 2: Create a media item
                    const createResponse = await fetch('https://photoslibrary.googleapis.com/v1/mediaItems:batchCreate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.accessToken}`
                        },
                        body: JSON.stringify({
                            newMediaItems: [{
                                description: `Selfie captured by Smart Selfie Camera on ${new Date().toLocaleString()}`,
                                simpleMediaItem: {
                                    fileName: filename,
                                    uploadToken: uploadToken
                                }
                            }]
                        })
                    });

                    if (!createResponse.ok) {
                        const errorJson = await createResponse.json();
                        throw new Error(`Media item creation failed: ${createResponse.status} - ${JSON.stringify(errorJson)}`);
                    }
                    
                    const result = await createResponse.json();
                    // Check if newMediaItemResults exists and has at least one item
                    if (result.newMediaItemResults && result.newMediaItemResults.length > 0) {
                        const itemResult = result.newMediaItemResults[0];
                        // If mediaItem is present, it was successful
                        if (itemResult.mediaItem) {
                            this.showStatus('Photo uploaded to Google Photos successfully!', 'success');
                        } else if (itemResult.status) {
                            // If status is present, it indicates an error for that specific item
                            throw new Error(`Google Photos API error: ${itemResult.status.message || 'Unknown error'}`);
                        } else {
                            // Fallback for unexpected response structure
                            throw new Error('Google Photos API: Unexpected response structure after batchCreate.');
                        }
                    } else {
                        throw new Error('Google Photos API: No media item results found in response.');
                    }

                } catch (error) {
                    console.error('Google Photos upload error:', error);
                    this.showStatus(`Failed to upload: ${error.message}`, 'error');
                }
            }

            async startCamera() {
                try {
                    this.showStatus('Starting camera...', 'loading');
                    
                    const constraints = {
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    };

                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;

                    await new Promise((resolve) => {
                        this.video.onloadedmetadata = resolve;
                    });

                    this.startBtn.disabled = true;
                    this.captureBtn.disabled = false;
                    this.stopBtn.disabled = false;

                    this.statusOverlay.textContent = 'Camera Active';
                    this.showStatus('Camera started successfully!', 'success');

                    if (this.isAIDetectionActive) {
                        this.startAIDetection();
                        this.statusOverlay.textContent = 'Camera Active - AI Detection ON';
                    }

                } catch (error) {
                    console.error('Camera access error:', error);
                    this.showStatus('Camera access denied. Please allow camera permission.', 'error');
                }
            }

            stopCamera() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }

                this.video.srcObject = null;
                this.startBtn.disabled = false;
                this.captureBtn.disabled = true;
                this.stopBtn.disabled = true;

                this.statusOverlay.textContent = 'Camera Stopped';
                this.showStatus('Camera stopped successfully.', 'success');
                this.faceIndicator.style.display = 'none';
                this.smileIndicator.style.display = 'none';
                this.gestureIndicator.style.display = 'none';

                this.stopAIDetection();
            }

            capturePhoto() {
                if (!this.video.videoWidth || !this.video.videoHeight) {
                    this.showStatus('Video not loaded yet. Please wait a moment.', 'error');
                    return;
                }

                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;

                this.ctx.save();
                this.ctx.scale(-1, 1);
                this.ctx.drawImage(this.video, -this.canvas.width, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();

                const format = this.formatSelect.value;
                const quality = format === 'image/jpeg' ? 0.9 : undefined;

                this.canvas.toBlob((blob) => {
                    this.photoCount++;
                    const fileName = `selfie_${this.photoCount}_${Date.now()}`;
                    
                    this.addToPreview(blob, fileName, format);
                    this.showStatus(`Photo captured successfully! Format: ${format.split('/')[1].toUpperCase()}`, 'success');
                }, format, quality);
            }

            addToPreview(blob, fileName, format) {
                const url = URL.createObjectURL(blob);
                const extension = format.split('/')[1];
                const id = `photo-${Date.now()}`;
                
                const previewItem = document.createElement('div');
                previewItem.className = 'preview-item';
                previewItem.id = id;
                
                previewItem.innerHTML = `
                    <img src="${url}" alt="Selfie">
                    <div>
                        <p style="margin-bottom: 10px; font-size: 12px;">${fileName}.${extension}</p>
                        <button class="download-btn">Download</button>
                        <button class="delete-btn">Delete</button>
                        <button class="upload-btn">Upload to Photos</button>
                    </div>
                `;

                const downloadBtn = previewItem.querySelector('.download-btn');
                downloadBtn.addEventListener('click', () => this.downloadImage(url, `${fileName}.${extension}`));

                const deleteBtn = previewItem.querySelector('.delete-btn');
                deleteBtn.addEventListener('click', () => this.deleteImage(id, url));

                const uploadBtn = previewItem.querySelector('.upload-btn');
                uploadBtn.addEventListener('click', () => this.uploadToGooglePhotos(this.getBlobById(id), `${fileName}.${extension}`));

                this.previewContainer.prepend(previewItem);
                this.storeBlob(id, blob);
            }

            storeBlob(id, blob) {
                this.capturedBlobs[id] = blob;
            }

            getBlobById(id) {
                return this.capturedBlobs[id];
            }

            removeBlob(id) {
                delete this.capturedBlobs[id];
            }

            downloadImage(url, filename) {
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                this.showStatus(`${filename} downloaded successfully!`, 'success');
            }

            deleteImage(id, url) {
                const itemToRemove = document.getElementById(id);
                if (itemToRemove) {
                    itemToRemove.remove();
                    URL.revokeObjectURL(url);
                    this.removeBlob(id);
                    this.showStatus('Photo deleted successfully!', 'success');
                }
            }

            toggleAIDetection() {
                this.isAIDetectionActive = !this.isAIDetectionActive;
                this.aiToggle.classList.toggle('active');
                this.aiStatus.textContent = this.isAIDetectionActive ? 'ON' : 'OFF';

                if (this.isAIDetectionActive) {
                    this.detectionSettings.style.display = 'block';
                    this.showStatus('AI Detection enabled! üòä Smile or use gestures for auto capture', 'success');
                    if (this.stream) {
                        this.startAIDetection();
                        this.statusOverlay.textContent = 'Camera Active - AI Detection ON';
                    }
                } else {
                    this.detectionSettings.style.display = 'none';
                    this.showStatus('AI Detection disabled.', 'success');
                    this.stopAIDetection();
                    this.faceIndicator.style.display = 'none';
                    this.smileIndicator.style.display = 'none';
                    this.gestureIndicator.style.display = 'none';
                    if (this.stream) {
                        this.statusOverlay.textContent = 'Camera Active';
                    }
                }
            }

            startAIDetection() {
                if (this.detectionInterval) return;

                this.detectionHistory = [];
                this.frameCount = 0;
                this.lastFaceData = null;
                this.lastGestureData = null;

                this.detectionInterval = setInterval(() => {
                    this.processFrameForDetection();
                }, 200);
            }

            stopAIDetection() {
                if (this.detectionInterval) {
                    clearInterval(this.detectionInterval);
                    this.detectionInterval = null;
                }
                this.detectionHistory = [];
                this.frameCount = 0;
            }

            processFrameForDetection() {
                if (!this.video.videoWidth || !this.video.videoHeight) return;

                this.frameCount++;
                
                this.analysisCtx.save();
                this.analysisCtx.scale(-1, 1);
                this.analysisCtx.drawImage(this.video, -this.analysisCanvas.width, 0, this.analysisCanvas.width, this.analysisCanvas.height);
                this.analysisCtx.restore();
                
                const imageData = this.analysisCtx.getImageData(0, 0, this.analysisCanvas.width, this.analysisCanvas.height);

                const faceRegion = this.extractFaceRegion(this.analysisCtx);
                const mouthRegion = this.extractMouthRegion(this.analysisCtx);
                const eyeRegion = this.extractEyeRegion(this.analysisCtx);
                
                let smileMetrics = { smileScore: 0, mouthAspectRatio: 0 };
                if (faceRegion && mouthRegion && eyeRegion) {
                    smileMetrics = this.calculateSmileMetrics(faceRegion, mouthRegion, eyeRegion);
                }

                const gestureMetrics = this.detectTwoFingerGesture(imageData);

                this.updateDebugInfo(smileMetrics, gestureMetrics);
                
                this.detectionHistory.push({ smileMetrics, gestureMetrics });
                if (this.detectionHistory.length > 5) {
                    this.detectionHistory.shift();
                }

                if (this.detectionHistory.length >= 3) {
                    const isSmiling = this.analyzeSmilePattern();
                    const isGesture = this.analyzeGesturePattern();
                    
                    if ((isSmiling || isGesture) && Date.now() - this.lastAutoCaptureTime > 5000) {
                        this.triggerAutoCapture(isSmiling ? 'smile' : 'gesture');
                    }
                }
            }

            extractFaceRegion(ctx) {
                try {
                    return ctx.getImageData(80, 60, 160, 120);
                } catch (e) {
                    return null;
                }
            }

            extractMouthRegion(ctx) {
                try {
                    return ctx.getImageData(120, 140, 80, 40);
                } catch (e) {
                    return null;
                }
            }

            extractEyeRegion(ctx) {
                try {
                    return ctx.getImageData(100, 80, 120, 30);
                } catch (e) {
                    return null;
                }
            }

            calculateSmileMetrics(faceRegion, mouthRegion, eyeRegion) {
                const faceMetrics = this.analyzeRegion(faceRegion.data);
                const mouthMetrics = this.analyzeRegion(mouthRegion.data);
                const eyeMetrics = this.analyzeRegion(eyeRegion.data);

                const mouthAspectRatio = this.calculateAspectRatio(mouthRegion.data, 80, 40);
                const eyeContrast = eyeMetrics.contrast;
                
                const smileScore = this.calculateSmileScore(faceMetrics, mouthMetrics, eyeMetrics, mouthAspectRatio);

                return {
                    smileScore,
                    mouthBrightness: mouthMetrics.brightness,
                    mouthContrast: mouthMetrics.contrast,
                    eyeContrast,
                    mouthAspectRatio,
                    faceStability: faceMetrics.stability
                };
            }

            analyzeRegion(data) {
                let brightness = 0;
                const pixelCount = data.length / 4;
                
                for (let i = 0; i < data.length; i += 4) {
                    brightness += (data[i] + data[i + 1] + data[i + 2]) / 3;
                }
                brightness = brightness / pixelCount;
                
                let contrast = 0;
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    contrast += Math.pow(gray - brightness, 2);
                }
                contrast = Math.sqrt(contrast / pixelCount);
                
                return {
                    brightness,
                    contrast,
                    stability: this.lastFaceData ? Math.abs(brightness - this.lastFaceData.brightness) : 0
                };
            }

            calculateAspectRatio(data, width, height) {
                let horizontalVariation = 0;
                
                for (let y = 0; y < height; y += 2) {
                    let rowBrightness = 0;
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        rowBrightness += (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    }
                    if (y > 0 && this.lastRowBrightness !== undefined) {
                        horizontalVariation += Math.abs(rowBrightness - this.lastRowBrightness);
                    }
                    this.lastRowBrightness = rowBrightness;
                }
                
                return horizontalVariation / height;
            }

            calculateSmileScore(faceMetrics, mouthMetrics, eyeMetrics, mouthAspectRatio) {
                let score = 0;
                
                if (this.lastFaceData) {
                    const mouthBrightnessIncrease = mouthMetrics.brightness - this.lastFaceData.mouthBrightness;
                    if (mouthBrightnessIncrease > 8) score += 30;
                    else if (mouthBrightnessIncrease > 4) score += 15;
                }
                
                if (this.lastFaceData) {
                    const contrastIncrease = mouthMetrics.contrast - this.lastFaceData.mouthContrast;
                    if (contrastIncrease > 6) score += 25;
                    else if (contrastIncrease > 3) score += 12;
                }
                
                if (this.lastFaceData) {
                    const eyeChange = Math.abs(eyeMetrics.contrast - this.lastFaceData.eyeContrast);
                    if (eyeChange > 5) score += 20;
                }
                
                if (mouthAspectRatio > 15) score += 15;
                else if (mouthAspectRatio > 10) score += 8;
                
                if (faceMetrics.stability < 5) score += 10;
                
                this.lastFaceData = {
                    mouthBrightness: mouthMetrics.brightness,
                    mouthContrast: mouthMetrics.contrast,
                    eyeContrast: eyeMetrics.contrast,
                    brightness: faceMetrics.brightness
                };
                
                return Math.min(score, 100);
            }

            analyzeSmilePattern() {
                if (this.detectionHistory.length < 3) return false;
                
                const recentScores = this.detectionHistory.slice(-3).map(h => h.smileMetrics.smileScore);
                const avgScore = recentScores.reduce((a, b) => a + b, 0) / recentScores.length;
                
                const threshold = 55 - (this.sensitivity * 3);
                
                const consistentSmile = recentScores.every(score => score > threshold);
                const strongSmile = avgScore > threshold + 10;
                
                if (avgScore > 20) {
                    this.showFaceIndicator();
                } else {
                    this.faceIndicator.style.display = 'none';
                }
                
                if (avgScore > threshold - 10) {
                    this.smileIndicator.style.display = 'block';
                    setTimeout(() => {
                        this.smileIndicator.style.display = 'none';
                    }, 1000);
                }
                
                return consistentSmile && strongSmile;
            }

            detectTwoFingerGesture(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;

                let skinPixels = 0;
                let finger1X = 0, finger1Y = 0;
                let finger2X = 0, finger2Y = 0;
                let fingerCount = 0;

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    if (r > 95 && g > 40 && b > 20 &&
                        r > g && r > b &&
                        Math.abs(r - g) > 15 &&
                        data[i + 3] > 100) {
                        
                        skinPixels++;
                        const x = (i / 4) % width;
                        const y = Math.floor((i / 4) / width);

                        if (fingerCount === 0) {
                            finger1X = x;
                            finger1Y = y;
                            fingerCount = 1;
                        } else if (fingerCount === 1) {
                            const dist = Math.sqrt(Math.pow(x - finger1X, 2) + Math.pow(y - finger1Y, 2));
                            if (dist > 50) {
                                finger2X = x;
                                finger2Y = y;
                                fingerCount = 2;
                            }
                        }
                    }
                }

                let gestureScore = 0;
                if (fingerCount >= 2) {
                    const distance = Math.sqrt(Math.pow(finger1X - finger2X, 2) + Math.pow(finger1Y - finger2Y, 2));
                    if (distance > 100) {
                        gestureScore = Math.min(100, distance / 2);
                    }
                }
                
                this.lastGestureData = {
                    gestureScore: gestureScore
                };

                return { gestureScore };
            }

            analyzeGesturePattern() {
                if (this.detectionHistory.length < 3) return false;

                const recentGestureScores = this.detectionHistory.slice(-3).map(h => h.gestureMetrics.gestureScore);
                const avgGestureScore = recentGestureScores.reduce((a, b) => a + b, 0) / recentGestureScores.length;

                const gestureThreshold = 40 + (this.sensitivity * 3);

                const consistentGesture = recentGestureScores.every(score => score > gestureThreshold);
                const strongGesture = avgGestureScore > gestureThreshold + 10;

                if (avgGestureScore > gestureThreshold - 10) {
                    this.gestureIndicator.style.display = 'block';
                    setTimeout(() => {
                        this.gestureIndicator.style.display = 'none';
                    }, 1000);
                }

                return consistentGesture && strongGesture;
            }

            showFaceIndicator() {
                this.faceIndicator.style.display = 'block';
                this.faceIndicator.style.left = '25%'; 
                this.faceIndicator.style.top = '20%';
                this.faceIndicator.style.width = '50%';
                this.faceIndicator.style.height = '60%';
            }

            triggerAutoCapture(triggerType) {
                this.lastAutoCaptureTime = Date.now();
                this.capturePhoto();
                
                this.detectionHistory = this.detectionHistory.slice(Math.max(0, this.detectionHistory.length - 2));
                
                let message = '';
                if (triggerType === 'smile') {
                    message = 'Perfect Smile Detected! üì∏';
                    this.smileIndicator.style.display = 'block';
                    this.smileIndicator.textContent = 'üì∏ Perfect Shot!';
                    this.gestureIndicator.style.display = 'none';
                } else if (triggerType === 'gesture') {
                    message = 'Gesture Detected! üì∏';
                    this.gestureIndicator.style.display = 'block';
                    this.gestureIndicator.textContent = 'üì∏ Perfect Shot!';
                    this.smileIndicator.style.display = 'none';
                }

                this.statusOverlay.textContent = message;
                
                setTimeout(() => {
                    if (this.stream) {
                        this.statusOverlay.textContent = 'Camera Active - AI Detection ON';
                        this.smileIndicator.textContent = 'üòä Smile Detected!';
                        this.smileIndicator.style.display = 'none';
                        this.gestureIndicator.textContent = '‚úåÔ∏è Gesture Detected!';
                        this.gestureIndicator.style.display = 'none';
                    }
                }, 3000);
            }

            updateDebugInfo(smileMetrics, gestureMetrics) {
                document.getElementById('face-status').textContent = smileMetrics.smileScore > 20 ? 'Yes' : 'No';
                this.debugSmileScore.textContent = Math.round(smileMetrics.smileScore);
                this.debugMouthOpening.textContent = Math.round(smileMetrics.mouthAspectRatio);
                this.debugGestureScore.textContent = Math.round(gestureMetrics.gestureScore);
            }

            showStatus(message, type) {
                if (type === 'loading') {
                    this.statusMessage.innerHTML = `<div class="status-with-loader"><div class="loading"></div><span>${message}</span></div>`;
                } else {
                    this.statusMessage.textContent = message;
                }
                this.statusMessage.className = `status ${type}`;
                this.statusMessage.style.display = 'block';

                setTimeout(() => {
                    this.statusMessage.style.display = 'none';
                }, 4000);
            }
        }

        // Load Google API scripts dynamically
        function loadGoogleAPI() {
            return new Promise((resolve, reject) => {
                let scriptsLoaded = 0;
                const totalScripts = 2;
                
                function checkComplete() {
                    scriptsLoaded++;
                    if (scriptsLoaded === totalScripts) {
                        gapiReady = true;
                        resolve();
                    }
                }

                // Load Google API script
                const gapiScript = document.createElement('script');
                gapiScript.src = 'https://apis.google.com/js/api.js';
                gapiScript.onload = () => {
                    gapi.load('client', checkComplete);
                };
                gapiScript.onerror = reject;
                document.head.appendChild(gapiScript);

                // Load Google Identity Services script
                const gisScript = document.createElement('script');
                gisScript.src = 'https://accounts.google.com/gsi/client';
                gisScript.onload = checkComplete;
                gisScript.onerror = reject;
                document.head.appendChild(gisScript);
            });
        }

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Initialize camera first
                smartCameraInstance = new SmartSelfieCamera();
                
                // Load Google API in background
                await loadGoogleAPI();
                console.log('Google API loaded successfully');
                
                // Initialize Google Auth
                if (smartCameraInstance) {
                    smartCameraInstance.initGoogleAuth();
                }
            } catch (error) {
                console.error('Error loading Google API:', error);
                console.log('Camera will work without Google Photos integration');
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !e.repeat) {
                e.preventDefault();
                if (smartCameraInstance && !smartCameraInstance.captureBtn.disabled) {
                    smartCameraInstance.capturePhoto();
                }
            }
        });

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (smartCameraInstance) {
                if (document.hidden && smartCameraInstance.stream) {
                    smartCameraInstance.stopAIDetection();
                } else if (!document.hidden && smartCameraInstance.isAIDetectionActive && smartCameraInstance.stream) {
                    smartCameraInstance.startAIDetection();
                }
            }
        });

        // Double-click to toggle debug mode
        document.addEventListener('dblclick', () => {
            const debugInfo = document.getElementById('debug-info');
            debugInfo.style.display = debugInfo.style.display === 'none' ? 'block' : 'none';
        });
    </script>
</body>
</html>
